{-# OPTIONS_GHC -Wall #-}

import Data.ByteString.Lazy qualified as LBS
import Data.Foldable (for_)
import Distribution.PackageDescription (PackageDescription (..))
import Distribution.Simple (defaultMainWithHooks, simpleUserHooks)
-- import Distribution.Simple.Build
--   ( initialBuildSteps,
--   )
import Distribution.Simple.Compiler (CompilerFlavor (..), compilerFlavor)
import Distribution.Simple.Program (Program (..), requireProgram)
import Distribution.Simple.Program.Builtin (ghcProgram, ghcjsProgram, haskellSuiteProgram, jhcProgram, uhcProgram)
import Distribution.Simple.Setup (ConfigFlags (..))
import Distribution.Simple.ShowBuildInfo (mkBuildInfo)
import Distribution.Simple.UserHooks (Args, UserHooks (..))
import Distribution.Types.LocalBuildInfo (LocalBuildInfo (..), allTargetsInBuildOrder')
import Distribution.Utils.Json (renderJson)
import Distribution.Verbosity qualified as Verbosity
import System.Directory (getCurrentDirectory)

main :: IO ()
main = defaultMainWithHooks simpleUserHooks {postConf = postConf'}

-- TODO: try to load the setup-config instead. In this way we can make many smaller utilities.
-- See Distribution.Simple.Configure.getConfigStateFile

postConf' :: Args -> ConfigFlags -> PackageDescription -> LocalBuildInfo -> IO ()
postConf' _args _flags pkg_descr lbi = do
  -- pkg_descr or localPkgDescr? In simple setups it does not matter.
  let activeTargets = allTargetsInBuildOrder' pkg_descr lbi

  (compilerProg, _) <-
    let program = flavorToProgram (compilerFlavor (compiler lbi))
     in requireProgram Verbosity.silent program (withPrograms lbi)

  pwd <- getCurrentDirectory
  let (warns, json) = mkBuildInfo pwd pkg_descr lbi mempty (compilerProg, compiler lbi) activeTargets
  for_ warns $ putStrLn . ("Warning: " ++)

  -- -- Creates the autogenerated files for all configured components.
  -- -- NOTE: or use
  -- -- Distribution.Simple.Build.PathsModule.generatePathsModule
  -- -- Distribution.Simple.Build.PackageInfoModule.generatePackageInfoModule
  -- -- Distribution.Simple.Build.Macros.generateCabalMacrosHeader
  -- initialBuildSteps undefined pkg_descr lbi Verbosity.silent

  LBS.writeFile "buildinfo.json" $ renderJson json

-- Given the flavor of the compiler, try to find out which program we need.
flavorToProgram :: CompilerFlavor -> Program
flavorToProgram GHC = ghcProgram
flavorToProgram GHCJS = ghcjsProgram
flavorToProgram UHC = uhcProgram
flavorToProgram JHC = jhcProgram
flavorToProgram HaskellSuite {} = haskellSuiteProgram
flavorToProgram cf = error $ "flavorToProgram: unsupported compiler flavor: " ++ show cf
